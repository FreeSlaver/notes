* 数据库索引总结及笔试面试题
** 什么是索引
*** like语句是否使用索引？
    要分情况，如果通配符在后面，使用索引；如果通配符在前面，不使用索引。
*** 索引的优缺点
**** 优点
     1. 大大提高查询速度
**** 缺点
     1. 占用磁盘空间；
     2. 需要维护索引，
     3. 插入，删除操作会更加耗时。
** 复合索引
   两个以上列建立的索引是复合索引。
   复合索引的顺序很重要，执行查询时从前面的列开始更加有效，
   1. 经常仅对一个列多次搜索，则该列应该是第一列。
   2.

** 怎么优化一个SQL慢查询？
** B+树
   B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。
** 草稿
   读写比例10:1，插入和更新很少出问题，最容易出问题的是复杂查询。
   SELECT
       COUNT(*)
   FROM
       task
  WHERE
      STATUS = 2
      AND operator_id = 20839
      AND operate_time > 1371169729
      AND operate_time < 1371174603
      AND type=2
   在看文章之前，我自己先思考下，其实他么很简单，首先查询的顺序要改下。
   看整个SQL语句的含义，应该是查询某个操作人在某个时间段内的某个类型的操作数量，应该是比较频繁的操作。
   因为status，type的种类就那么多，比如2,3个固定的值，所以走索引和过滤出来的结果集都很大， 应该放后面，
   operator_id因为有确定的值，所以应该放在前面，而且应当建立索引，而operate_time很明显是一个
   时间戳排序字段，因此也应该建立索引，而根据最左优先原则，会对第一个索引排序，因此最好建立一个复合索引，
   alert table add index index_op(operate_time,opereator_id)，而且这个count(*)最好也改下，但是为嘛了？

   然后查询语句改成：
   SELECT
       COUNT(*)
   FROM
       task
   WHERE
       operate_time < 1371174603
       AND operate_time > 1371169729
       AND operate_id = 20839
       AND STATUS = 2
       AND type = 2

   最左前缀匹配，就是从复合索引最左边的字段先开始进行匹配，而因为WHERE从最后一列先开始条件过滤，
   最左前缀的字段应该放在WHERE的最后面。（不太对，最左前缀一直会在WHERE条件中从左至右进行匹配，所以范围查询条件放最后，如> < between等）
   索引的原理就是 *不断缩小查找的范围* 筛选出最终想要的结果。

   磁盘访问成本是内存的10万倍。
   每次查找数据时把磁盘IO次数控制在一个很小的数量级

   改正结果：
   SELECT
       COUNT(*)
   FROM
       task
   WHERE
       status=2
       AND type=2
       AND operate_id = 20839
       AND operate_time < 1371174603
       AND operate_time >1371169729
   索引的顺序是(status,type,operate_id,operate_time)这里status，type，operate_id的索引可以乱序，查询语句中也可以乱序。
   但是如果status经常在其他sql语句中出现的话，status就应该作为最左列前缀。
*** 索引建立的几大原则
    1. 最左前缀匹配，mysql会一直向右匹配，直到遇到范围查询（<.>.between,like）就停止匹配
       例子：a=1 and b=2 and c>3 and d=4，如果索引是(a,b,c,d)，那么d就不会使用到索引，因为c>3
       是一个范围查询，在d=4前面。
    2. 尽量选择不重复的字段做索引，因为能得到更小的结果集，比如唯一键就非常好，
    3. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序
       因为=可以乱序，所以这里operate_id不一定非得放到最左边。
    4. 不要对索引列进行计算，例子：from_unixtime(create_time) = '2014-05-29'换成create_time=unix_timestamp(''2014-05-29)
    5. 尽量扩展索引，而不要新建索引。
    6. 还要观察其他的SQL语句，看经常用到的字段有哪些，经常用到的放到最左列。
*** 慢查询优化
    使用Explain，关键点是：先查询得到结果集较小的Rows，然后再去联合其他结果集。

    大概原理就是：复杂又慢的联合查询，需要先单表查询，然后看哪个表的哪个字段区分度最高，
    也就是得到的结果集最少，将这样的放在左边，先得到结果集再去联合其他表。
    对于有order by limit等的字段，让这些字段所在的表先进行查询，排序。

    最后根据查询顺序，看看索引的建立是否满足上面的原则。

* Redis持久化-翻译
  Redis支持2种形式的持久化机制，RDB和AOF。
  你也可以不使用持久化机制，性能会更好，但是宕机后重启，数据都会丢失。
  也可以同时使用AOF和RDB，但在Redis重启时，只使用AOF方式进行恢复，因为AOF的数据更完整。
** RDB
   间隔指定时间做一个当前时间点的快照，使用fork和copy-on-write机制
*** RDB的优点
    1. 单个时间点对应单个压缩文件，做备份非常好。
        比如你可以每个小时，每天做一个备份。
    2. 便于灾难恢复，单个压缩文件很容易在数据中心间传输
    3. 最大化redis的性能，定时持久化时，只需fork一个子进程来进行IO操作
    4. 在大数据集下，RDB能更快启动
*** RDB的缺点
    1. 容易丢数据
    在2次持久化之间，如果redis挂了，持久化定时任务没得到执行，就会丢数据。
    虽然可以通过设置更短的时间间隔，比如5分钟，但是依然会丢数据。而且，
    不够灵活，产生的数据文件会非常多。
    2. 会造成服务短暂停顿
    每次执行持久化任务，会调用fork()生成子进程，如果数据集太大，或cpu性能不好，，
    就会造成短暂停顿，停顿期间无法提供服务。
** AOF
   server接收到的更新操作会使用append-only方式持久化到日志中。重启时，通过重读日志构建内存数据库。
*** AOF的优点
    1. 更具持久性
    可以采用不同的fsync策略：无fsync，每秒fsync，每次查询fsync。
    默认策略是每秒fsync，使用后台线程进行IO操作，主线程会在没有fsync线程时，
    努力写操作。但依然可能会丢掉1秒的数据。
    2. append only
    没有检索，没有脏数据问题，即使一个操作只写了一般，可以用redis-check-aof工具修复
    3. 可以在后台自动重新AOF文件，当文件太大。原文件继续工作，直到新文件完成
    4.AOF文件都是Redis指令，更易懂，能解析
    并且能够手动修改，去掉部分命令不让执行。
*** AOF的缺点
    1. 比RDB文件更大
    2. 有fsync机制时，稍慢
    3. 有很低几率出Bug
*** AOF文件过大问题
    就是通过后台进程对AOF文件进行重写，只保留Key的最终值。
** 持久化额外知识
   看看一个数据库写操作发生了什么
   1. 客户端向db发送一条写命令（数据在客户端内存）
   2. db接收到写请求（数据在服务器端内存）
   3. db调用系统方法将数据写到磁盘（数据在内核缓冲区）
   4. 操作系统将写缓冲传输给磁盘控制器（数据在磁盘缓存中）
   5. 磁盘控制器最终将数据写入到物理介质

** 参考资料和扩展阅读

   [[http://oldblog.antirez.com/post/redis-persistence-demystified.html][Redis persistence demystified]]

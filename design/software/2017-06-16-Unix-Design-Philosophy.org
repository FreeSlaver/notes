* Unix设计哲学
  程序只应该关注一个目标，只做一件事并做好它。

  1. 你永远不会知道你的程序会在什么地方耗费时间。程序的瓶颈常常出现在意想不到的地方，
     因此在你确信找到了瓶颈后再动手优化代码把。

  2. 测试代码，只有在你详细测试了代码，并且发现一部分代码耗费了绝大部分的运行时间时，
     再对程序做速度优化。

  3. fancy algorithm在处理小规模问题是效率很低。让代码丑陋但是简单高效吧。

  4. fancy algorithm比简单的算法更容易产生bug，更难使用。尽量使用简单的算法和数据结构。

  5. 数据决定一切。如果选择的数据结构能很好的管理数据，算法部分往往不言自明。
     记住，数据结构（数据的组织，层级方式），而非算法，才是编程的关键。

  6. 没有第六条规则。

  过早的优化是一切罪恶的根源。

  小即是美。
  让程序制作好一件事。
  尽可能早的创建原型
  可移植性比效率更重要
  数据应该保存为文本文件
  尽可能的榨取软件的全部价值
  使用shell脚本来提高效率和可移植性
  避免使用可定制性地下的用户界面
  所有程序都是数据的过滤器

  worse is better接口和实现的简单性比系统的任何其他属性都更重要，包括准确性，一致性和完整性。

      Unix编程哲学：

 1，模块原则：使用简洁的接口拼合简单的部件。

2，清晰原则：清晰胜于机巧。

3，组合原则：设计时考虑拼接组合。

4，分离原则：策略同机制分离，接口同实现引擎分离。

5，简洁原则：设计要简洁，复杂度能低则低。

6，吝啬原则：除非确无它法，不要编写庞大的程序。

7，透明性原则：设计要可见，以便审查和调试。

8，健壮原则：健壮源于透明与简洁。

9，表示原则：把知识叠入数据以求逻辑质朴而健壮。

10，通俗原则：接口设计避免标新立异。

11，缄默原则：如果一个程序没什么好说的，就沉默。

12，补救原则：出现异常时，马上退出并给出足够的错误信息。

13，经济原则：宁花机器一分，不花程序员一秒。

14，生成原则：避免手工hack，尽量编写程序去生成程序。

15，优化原则：雕琢前先要有原型，跑之前先学会走。

16，多样原则：绝不相信所谓“不二法门”的断言。

17，扩展原则：设计着眼未来，未来总比预想来得快。

    Unix编程哲学：

 1，模块原则：使用简洁的接口拼合简单的部件。

2，清晰原则：清晰胜于机巧。

3，组合原则：设计时考虑拼接组合。

4，分离原则：策略同机制分离，接口同实现引擎分离。

5，简洁原则：设计要简洁，复杂度能低则低。

6，吝啬原则：除非确无它法，不要编写庞大的程序。

7，透明性原则：设计要可见，以便审查和调试。

8，健壮原则：健壮源于透明与简洁。

9，表示原则：把知识叠入数据以求逻辑质朴而健壮。

10，通俗原则：接口设计避免标新立异。

11，缄默原则：如果一个程序没什么好说的，就沉默。

12，补救原则：出现异常时，马上退出并给出足够的错误信息。

13，经济原则：宁花机器一分，不花程序员一秒。

14，生成原则：避免手工hack，尽量编写程序去生成程序。

15，优化原则：雕琢前先要有原型，跑之前先学会走。

16，多样原则：绝不相信所谓“不二法门”的断言。

17，扩展原则：设计着眼未来，未来总比预想来得快。

"编程的本质是控制复杂度"，而流程图，过程化，结构化，面向对象以及其他方法
恰好“成功 "将复杂度降低到人脑能处理的底部。所以，降低整体复杂度的方式是用
清晰的接口将若干简单模块组合成一个复杂软件。

过载优化是唯一一个比乱加功能更损害设计的错误。“最强大的优化工具是DELETE键”

“善用工具”，教会电脑生成一些简单的代码；一旦有人解决了某个问题，就直接拿过来用，
尽可能一切都自动化。

职责过多，可能引起它变化的原因就越多，这将导致职责依赖，
相互之间就产生影响，从而极大的损伤其内聚性和耦合度。

Open/Closed Principle (OCP)
开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。
